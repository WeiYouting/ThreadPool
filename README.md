# ThreadPool

#### 项目背景

操作系统上创建线程和销毁线程都是很"重"的操作，耗时耗性能都比较多，那么在服务执行的过程中，如果业务量比较大，实时的去创线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能降低，业务的处理能力也会降低。

线程池的优势是在服务进程启动之初，就事先创建好线程池里面的线程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行task任务即可，task执行完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的task提供服务。



#### 关键技术点

##### 使用map和queue容器管理线程对象和任务

##### 基于条件变量condition_variable和互斥锁mutex实现任务提交线程和任务执行线程间的通信机制

##### 基于可变参模板编程和引用折叠原理，实现线程池submitTask接口，支持任意任务函数和任意参数的传递

##### 使用future类型定制submitTask提交任务的返回值

##### 支持fixed和cached模式的线程池定制



#### 功能介绍

线程池有fixed模式和cached模式区别在于线程池中的线程个数。

**fixed模式**:线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定。

**cached模式**:线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程数量的阈值，任务处理完成，如果动态增长的线程空闲了60s还没有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。

**TASK_MAX_THRESHHOLD**:任务队列最大容量

**TASK_COMMIT_TIMEOUT**:提交任务超时时间

**THREAD_MAX_THRESHHOLD**:线程池最大数量，fixed模式下为固定值，cached模式会动态增加或减小

**THREAD_MAX_IDLE_TIME**:线程最大空闲时间，cached模式下，创建的新线程长时间不执行任务时会销毁

调用start成员方法启动线程池后，可以提交函数对象和不定长参数，返回std::future对象，调用其get方法获得任务执行结果，当任务执行完成后线程进入睡眠状态等待新任务分配



#### 项目问题分析

在ThreadPool的资源回收，等待线程池所有线程退出时，由于获取锁和唤醒线程的时机不合适，发生死锁问题，导致进程无法退出

在windows平台下运行正常的线程池，在linux平台下运行发生死锁问题，使用gdb调试工具定位到死锁位置，由于对象已析构，而条件变量仍在等待，故发生死锁问题。

